# Cursor Rules for Nutriconsultas Project

## Project Context
This is a Spring Boot 3.4.1 web application for managing a nutrition consultation clinic. The project uses Java 21, Thymeleaf templates, PostgreSQL database, and Spring Security with OAuth2 authentication.

### Project Information
- **Project Name:** nutriconsultas
- **Company:** Minutriporcion
- **Branding:** Minutriporcion is the product and branding name for the nutriconsultas project. The project "nutriconsultas" is developed for the company Minutriporcion.

## Technology Stack
- Spring Boot 3.4.1
- Java 21
- Thymeleaf (template engine)
- PostgreSQL (production), H2 (testing)
- Spring Security with OAuth2 (Auth0)
- Maven build system
- Lombok for reducing boilerplate

## Code Quality Requirements

### Formatting
- Use Spring Java Format (automatically applied via Maven)
- Maximum line length: 120 characters
- Run `mvn spring-javaformat:apply` before committing

### Linting Tools
- **Spring Java Format**: Automatic code formatting
  - Command: `mvn spring-javaformat:apply`
  - Fixes: spacing, indentation, braces automatically
  - Runs during `validate` phase
- **Checkstyle**: Enforces code style (checkstyle.xml)
  - Command: `mvn checkstyle:check`
  - Runs during `validate` phase
  - **Common violations and fixes:**
    - **NeedBraces**: Always use braces for if/for/while statements
      - ❌ `if (condition) statement;`
      - ✅ `if (condition) { statement; }`
    - **LineLength**: Keep lines under 120 characters
      - Break long lines, extract variables, use method chaining on separate lines
    - **RightCurly**: Closing braces should be on same line as else/catch/finally
      - ❌ `} else {` on separate lines
      - ✅ `} else {` on same line
    - **LocalFinalVariableName/LocalVariableName**: Variables must start with lowercase letter
      - ❌ `final Ingrediente _ingrediente = ...;` or `Paciente _paciente = ...;`
      - ✅ `final Ingrediente ingrediente = ...;` or `Paciente pacienteEntity = ...;`
    - **FinalClass**: Utility classes should be `final`
      - ❌ `public class IngredienteComparators { }`
      - ✅ `public final class IngredienteComparators { }`
    - **VisibilityModifier**: Fields should be private
      - ❌ `static Map map = ...;` or `AlimentosRepository alimentosRepository;`
      - ✅ `private static final Map MAP = ...;` or `private AlimentosRepository alimentosRepository;`
    - **HideUtilityClassConstructor**: Utility classes need private constructors
      - ❌ `public class WebContextFactory { }`
      - ✅ `public class WebContextFactory { private WebContextFactory() { } }`
    - **NoWhitespaceAfter**: No space after opening brace
      - ❌ `{ value }`
      - ✅ `{value}`
- **SpotBugs**: Static analysis for bugs
  - Command: `mvn spotbugs:check`
  - Common fixes: null checks, resource leaks, inefficient operations
  - Exclude false positives in `spotbugs-exclude.xml`
  - Runs during `verify` phase
- **PMD**: Code quality analysis
  - Command: `mvn pmd:check`
  - Custom ruleset: `pmd-ruleset.xml` (excludes ShortVariable for loop variables)
  - Common fixes:
    - **MethodArgumentCouldBeFinal**: Add `final` to method parameters
    - **LocalVariableCouldBeFinal**: Add `final` to local variables
    - **OnlyOneReturn**: Refactor to single return point
    - **LongVariable**: Shorten variable names
    - **UnusedAssignment**: Remove unused assignments
    - **GuardLogStatement**: Add log level guards (e.g., `if (logger.isDebugEnabled())`)
    - **AvoidCatchingGenericException**: Catch specific exceptions
  - Runs during `verify` phase
- **Thymeleaf Validator**: Validates template syntax
  - Modular architecture with per-template validators
  - Package: `com.nutriconsultas.validation.template`
  - Each template group has its own validator defining required mock model variables
  - To add a validator: extend `BaseTemplateValidator` and register in `TemplateValidatorRegistry`
- All tools run during build lifecycle
- Run all tools: `./lint.sh`

### Code Style
- Follow Spring Boot best practices
- Use constructor injection (preferred over field injection)
- Use Lombok `@Slf4j` for logging
- Maximum method length: 150 lines
- Maximum parameters: 7 per method
- Use `@Valid` for validation
- Remove unused imports
- **Naming Conventions:**
  - Classes: PascalCase (e.g., `MyClass`)
  - Methods/Variables: camelCase starting with lowercase (e.g., `myMethod`, `myVariable`)
  - **CRITICAL: NEVER use underscore prefix for variables** (e.g., `_variable` is invalid)
    - Use descriptive names: `pacienteEntity`, `savedDieta`, `ingredienteResult` instead of `_paciente`, `_dieta`, `_ingrediente`
  - Constants: UPPER_SNAKE_CASE (e.g., `MY_CONSTANT`)
- **Braces**: Always use braces for if/for/while statements
  - ❌ `if (condition) statement;`
  - ✅ `if (condition) { statement; }`
- **Utility Classes**: Must be `final` with private constructor
  - ❌ `public class MyComparators { }`
  - ✅ `public final class MyComparators { private MyComparators() { } }`
- **Field Visibility**: All fields must be private
  - ❌ `static Map map;` or `AlimentosRepository repository;`
  - ✅ `private static final Map MAP;` or `private AlimentosRepository repository;`
- **Brace Placement**: Closing braces should be on same line as else/catch/finally
  - ❌ `} else {` on separate lines
  - ✅ `} else {` on same line

## Project Structure

### Controllers
- **Web Controllers**: Use `@Controller` for Thymeleaf views
- **REST Controllers**: Use `@RestController` for API endpoints
- **Base Classes**:
  - `AbstractAuthorizedController`: For authenticated pages (adds user info to model)
  - `AbstractGridController`: For grid/list views
  - `AbstractGridItemController`: For grid item operations
- Controllers should be in package-specific directories (admin, paciente, dieta, etc.)

### Services
- Implement service interfaces
- Use `@Service` annotation
- Use `@Transactional` for database operations
- Follow naming: `XxxService` interface, `XxxServiceImpl` implementation

### Repositories
- Extend `JpaRepository<Entity, ID>`
- Use `@Repository` annotation (optional, Spring detects automatically)
- Use `@Query` for custom queries (prefer JPQL over native SQL)

### Templates
- **Admin Templates**: Located in `src/main/resources/templates/sbadmin/`
  - Used for authenticated admin pages (`/admin/**`)
  - Include fragments: sidebar, topbar, footer
  - Return path format: `"sbadmin/{module}/{view}"`
- **Public Templates**: Located in `src/main/resources/templates/eterna/`
  - Used for public pages (homepage, about, etc.)
  - Return path format: `"eterna/{view}"`
- Use Thymeleaf fragments for reusable components
- Use `th:` namespace for all Thymeleaf attributes
- Use `@{...}` for URL generation
- Use `${...}` for model attributes

### Security
- All `/rest/**` endpoints require authentication
- All `/admin/**` endpoints require authentication
- Public routes are accessible without authentication
- Use `AbstractAuthorizedController` for authenticated pages
- Security configuration in `SecurityConfig.java`

### Multi-Tenant Access Control

**CRITICAL: All patient data is isolated by user (nutritionist).**

The application implements multi-tenant access control where:
- **Patients belong to specific users**: Each `Paciente` entity has a `userId` field that stores the OAuth2 user identifier (the `sub` claim)
- **User isolation is enforced**: Users can only view and manage their own patients
- **No cross-user visibility**: Patient data is completely isolated per user

#### Implementation Details

1. **Entity Level**:
   - `Paciente` entity includes a `userId` field (String, nullable = false)
   - The `userId` stores the OAuth2 `sub` claim (unique user identifier from Auth0)

2. **Repository Level**:
   - `PacienteRepository` provides methods:
     - `findByUserId(String userId)` - Find all patients for a user
     - `findByIdAndUserId(Long id, String userId)` - Find a specific patient by ID and userId (for security)

3. **Service Level**:
   - `PacienteService` provides userId-filtered methods:
     - `findByIdAndUserId(Long id, String userId)` - Secure patient lookup
     - `findAllByUserId(String userId)` - Get all patients for a user
     - `deleteByIdAndUserId(Long id, String userId)` - Secure patient deletion

4. **Controller Level**:
   - All `PacienteController` methods that access patients:
     - Accept `@AuthenticationPrincipal OidcUser principal` parameter
     - Extract userId using `principal.getSubject()`
     - Use `findByIdAndUserId()` instead of `findById()` for security
     - Call `verifyPatientOwnership()` to ensure patient belongs to user
   - New patients automatically get `userId` set from the authenticated user

5. **REST API Level**:
   - `PacienteRestController` filters all patient data by userId
   - Overrides `getPageArray()` to accept `@AuthenticationPrincipal OidcUser principal`
   - Uses `findAllByUserId()` to return only the current user's patients

#### Security Best Practices

When working with patient data:

1. **Always use userId-filtered methods**: Never use `findById()` or `findAll()` directly
   - ✅ Use: `findByIdAndUserId(id, userId)`
   - ✅ Use: `findAllByUserId(userId)`
   - ❌ Avoid: `findById(id)` (no user filtering)
   - ❌ Avoid: `findAll()` (returns all patients)

2. **Always verify ownership**: Before accessing patient data, verify it belongs to the current user
   ```java
   final String userId = getUserId(principal);
   final Paciente paciente = repository.findByIdAndUserId(id, userId)
       .orElseThrow(() -> new IllegalArgumentException("Patient not found"));
   verifyPatientOwnership(paciente, userId);
   ```

3. **Set userId on creation**: When creating new patients, always set the userId
   ```java
   paciente.setUserId(getUserId(principal));
   ```

4. **Test multi-tenant scenarios**: All tests should verify:
   - Users can only see their own patients
   - Users cannot access other users' patients
   - Patient creation assigns correct userId

#### Related Entities

Entities that reference `Paciente` (like `CalendarEvent`, `ClinicalExam`, `AnthropometricMeasurement`) inherit patient ownership through the relationship. When verifying access to these entities:
1. Load the related entity
2. Access the `paciente` relationship
3. Verify the `paciente.userId` matches the current user's ID

#### Migration Notes

- Existing patients in the database may have `null` userId values
- A migration script may be needed to assign userId to existing patients
- New patients created after this implementation will automatically have userId set

## Best Practices

### Spring Boot
1. Use constructor injection for dependencies
2. Use `@Slf4j` from Lombok for logging
3. Use `@Valid` with Jakarta Validation annotations
4. Externalize configuration to `application.properties`
5. Use `@Configuration` classes for bean definitions
6. Write unit tests for services, integration tests for controllers
7. Use `@Transactional` on service methods, not controllers
8. Use proper exception handling with `@ControllerAdvice`

### Thymeleaf
1. Always use `th:` namespace attributes
2. Use fragments for reusable components (sidebar, footer, etc.)
3. Use `th:errors` to display validation errors
4. Use `th:if`/`th:unless` for conditional rendering
5. Use `@{...}` for URL generation (respects context path)
6. Access model attributes with `${attributeName}`
7. Use `th:text` for text content, `th:utext` for HTML content
8. Validate templates using ThymeleafValidator
9. **Template Validation**: When creating new templates, ensure a validator exists in `com.nutriconsultas.validation.template` package
   - If a template needs specific mock variables, create a validator extending `BaseTemplateValidator`
   - Register the validator in `TemplateValidatorRegistry`
   - Validators define mock model variables needed for template validation

### Database
1. Use JPA entities with proper relationships
2. Use Spring Data JPA repositories
3. Use `@Transactional` on service methods
4. Use `Pageable` for pagination
5. Prefer JPQL over native SQL queries
6. Use `@Query` annotation for custom queries

### Testing
1. Use H2 database for tests (configured in test profile)
2. Use `@SpringBootTest` for integration tests
3. Use `@WebMvcTest` for controller tests
4. Use `@MockBean` for mocking dependencies
5. Use Spring Security Test for security testing
6. Test data in `src/test/resources/`

### Testing Requirements (MANDATORY)
**CRITICAL: All code changes MUST include tests and template validations.**

When implementing features or making changes:

1. **Create Service Tests:**
   - Create `XxxServiceTest.java` in `src/test/java/` mirroring package structure
   - Use `@ExtendWith(MockitoExtension.class)` for unit tests
   - Mock dependencies with `@Mock`, inject service with `@InjectMocks`
   - Test all public methods, including success and error cases
   - Use AssertJ: `assertThat()`, `assertThatThrownBy()`

2. **Create Controller Tests:**
   - Create or update `XxxControllerTest.java`
   - Use `@SpringBootTest` with `@AutoConfigureMockMvc` for web tests
   - Or use `@ExtendWith(MockitoExtension.class)` with `@InjectMocks` for unit-style tests
   - Test all endpoints (GET, POST, PUT, DELETE)
   - Verify model attributes, view names, redirects
   - Use `@WithMockUser` for authenticated endpoints
   - Test validation errors and success paths

3. **Update Template Validators:**
   - If creating new templates, update corresponding `XxxTemplateValidator`
   - Add mock model variables for all template variables used
   - Validators in `com.nutriconsultas.validation.template` package
   - Register new validators in `TemplateValidatorRegistry` if needed

4. **Test Coverage:**
   - Test happy paths, error cases, edge cases
   - Verify exception handling
   - Test validation logic
   - Run `mvn test` before committing

**Example Service Test:**
```java
@ExtendWith(MockitoExtension.class)
@Slf4j
@ActiveProfiles("test")
public class ExampleServiceTest {
    @InjectMocks
    private ExampleServiceImpl service;
    @Mock
    private ExampleRepository repository;
    
    @Test
    public void testMethodName() {
        // Arrange, Act, Assert
    }
}
```

## File Naming Conventions
- Controllers: `XxxController.java`
- Services: `XxxService.java` (interface), `XxxServiceImpl.java` (implementation)
- Repositories: `XxxRepository.java`
- Entities: `Xxx.java` (singular, PascalCase)
- Templates: `{view}.html` (lowercase, kebab-case)
- Test classes: `XxxTest.java` or `XxxControllerTest.java`

## Common Patterns

### Controller Example
```java
@Controller
@Slf4j
public class ExampleController extends AbstractAuthorizedController {
    
    private final ExampleService service;
    
    public ExampleController(ExampleService service) {
        this.service = service;
    }
    
    @GetMapping("/example")
    public String list(Model model) {
        model.addAttribute("items", service.findAll());
        model.addAttribute("activeMenu", "example");
        return "sbadmin/example/list";
    }
}
```

### Service Example
```java
@Service
@Slf4j
public class ExampleServiceImpl implements ExampleService {
    
    private final ExampleRepository repository;
    
    public ExampleServiceImpl(ExampleRepository repository) {
        this.repository = repository;
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<Example> findAll() {
        return repository.findAll();
    }
}
```

### REST Controller Example
```java
@RestController
@RequestMapping("/rest/example")
@Slf4j
public class ExampleRestController {
    
    private final ExampleService service;
    
    // REST endpoints...
}
```

## Environment Variables
The application requires these environment variables (set in `.env` file):
- `JDBC_DATABASE_URL`
- `JDBC_DATABASE_USERNAME`
- `JDBC_DATABASE_PASSWORD`
- `AUTH_CLIENT`, `AUTH_SECRET`, `AUTH_ISSUER`
- `AWS_BUCKET`, `AWS_KEY`, `AWS_SECRET`
- `MAPS_KEY` (optional)

## Development Workflow
1. Make code changes
2. Run `mvn spring-javaformat:apply` to format code
3. Run `./lint.sh` to check code quality
4. Run `mvn test` to run tests
5. Commit changes (pre-commit hook will format code automatically)

## Important Notes
- Application runs on port 3000
- Database: PostgreSQL (development), H2 (testing)
- Session storage: JDBC-backed (PostgreSQL)
- Static assets: `src/main/resources/static/`
- All Thymeleaf templates must be valid (validated during build)
- Code formatting is enforced via git pre-commit hook
- CI/CD runs linting in strict mode (`ci` profile)

## When Making Changes
1. **New Controller**: Extend `AbstractAuthorizedController` if authentication required
2. **New Template**: Place in `sbadmin/` (admin) or `eterna/` (public) directory
3. **New Service**: Create interface and implementation
4. **New Entity**: Add JPA annotations, create repository
5. **New Test**: Mirror package structure, use appropriate test annotations
6. **Template Changes**: Ensure Thymeleaf syntax is valid
7. **Security Changes**: Update `SecurityConfig.java` if needed

## Avoid
- ❌ Field injection (use constructor injection)
- ❌ Star imports
- ❌ Unused imports
- ❌ Methods longer than 150 lines
- ❌ More than 7 parameters per method
- ❌ Native SQL queries (prefer JPQL)
- ❌ Hardcoded values (use properties)
- ❌ Missing validation annotations
- ❌ Missing `@Transactional` on service methods
- ❌ Mixing template directories (sbadmin vs eterna)
- ❌ Variables with underscore prefix (e.g., `_variable`, `_paciente`, `_dieta`)
- ❌ If/for/while statements without braces
- ❌ Public fields in classes (use private with accessors)
- ❌ Utility classes without `final` keyword and private constructor
- ❌ Lines longer than 120 characters
- ❌ Closing braces on separate line from else/catch/finally

